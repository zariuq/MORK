(program Z (JZ 2 (S (S (S (S (S Z))))) ))
(program (S Z) (DEC 2))
(program (S (S Z)) (INC 3))
(program (S (S (S Z))) (INC 1))
(program (S (S (S (S Z)))) (JZ 0 Z))
(program (S (S (S (S (S Z))))) (JZ 1 (S (S (S (S (S (S (S (S (S Z)))))))))))
(program (S (S (S (S (S (S Z)))))) (DEC 1))
(program (S (S (S (S (S (S (S Z))))))) (INC 2))
(program (S (S (S (S (S (S (S (S Z)))))))) (JZ 0 (S (S (S (S (S Z)))))))
(program (S (S (S (S (S (S (S (S (S Z))))))))) H)
(state Z (REG 0 Z))
(state Z (REG 1 Z))
(state Z (REG 2 (S (S (S (S (S Z)))))))
(state Z (REG 3 Z))
(state Z (REG 4 Z))
(state Z (IC Z))
(if (S $n) $x $y $x)
(if Z $x $y $y)
(0 != 1) (0 != 2) (0 != 3) (0 != 4)
(1 != 0) (1 != 2) (1 != 3) (1 != 4)
(2 != 1) (2 != 0) (2 != 3) (2 != 4)
(3 != 1) (3 != 2) (3 != 0) (3 != 4)
(4 != 1) (4 != 2) (4 != 0) (4 != 3)

((step JZ $ts)
  (, (state $ts (IC $i)) (program $i (JZ $r $j)) (state $ts (REG $r $v)) (if $v (S $i) $j $ni) (state $ts (REG $k $kv)))
  (, (state (S $ts) (IC $ni)) (state (S $ts) (REG $k $kv))))

((step INC $ts)
  (, (state $ts (IC $i)) (program $i (INC $r)) (state $ts (REG $r $v)) ($r != $o) (state $ts (REG $o $ov)))
  (, (state (S $ts) (IC (S $i))) (state (S $ts) (REG $r (S $v))) (state (S $ts) (REG $o $ov))))

((step DEC $ts)
  (, (state $ts (IC $i)) (program $i (DEC $r)) (state $ts (REG $r (S $v))) ($r != $o) (state $ts (REG $o $ov)))
  (, (state (S $ts) (IC (S $i))) (state (S $ts) (REG $r $v)) (state (S $ts) (REG $o $ov))))  

(exec (clocked Z)
        (, (exec (clocked $ts) $p1 $t1) 
           (state $ts (IC $_))
           ((step $k $ts) $p0 $t0))
        (, (exec ($k $ts) $p0 $t0)
           (exec (clocked (S $ts)) $p1 $t1)))